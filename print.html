<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PRQL Language Reference (draft)</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Modern language for transforming data — a simpler and more powerful SQL">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="comparison-table.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="queries/index.html"><strong aria-hidden="true">2.</strong> Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="queries/pipelines.html"><strong aria-hidden="true">2.1.</strong> Pipelines</a></li></ol></li><li class="chapter-item expanded "><a href="language-features/index.html"><strong aria-hidden="true">3.</strong> Language features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language-features/f-strings.html"><strong aria-hidden="true">3.1.</strong> F-Strings</a></li><li class="chapter-item expanded "><a href="language-features/ranges.html"><strong aria-hidden="true">3.2.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="language-features/dates.html"><strong aria-hidden="true">3.3.</strong> Dates</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Regex</div></li><li class="chapter-item expanded "><a href="language-features/s-strings.html"><strong aria-hidden="true">3.5.</strong> S-Strings</a></li></ol></li><li class="chapter-item expanded "><a href="transforms.html"><strong aria-hidden="true">4.</strong> Transforms</a></li><li class="chapter-item expanded "><a href="syntax.html"><strong aria-hidden="true">5.</strong> Syntax</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">6.</strong> Functions</a></li><li class="chapter-item expanded "><a href="stdlib.html"><strong aria-hidden="true">7.</strong> Stdlib</a></li><li class="chapter-item expanded "><a href="editor.html"><strong aria-hidden="true">8.</strong> Live Editor</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PRQL Language Reference (draft)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/prql/prql" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<blockquote>
<p>[Note that this is a very early version and actively being worked on; thanks for
your patience]</p>
</blockquote>
<p>PRQL is a modern language for transforming data — a simpler and more powerful
SQL. Like SQL, it's readable, explicit and declarative. Unlike SQL, it forms a
logical pipeline of transformations, and supports abstractions such as variables
and functions. It can be used with any database that uses SQL, since it
transpiles to SQL.</p>
<p>Let's get started with an example:</p>
<!-- TODO: resolve formatting — way too wide for the current preprocessor -->
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
filter country_code = &quot;USA&quot;                  # Each line transforms the previous result.
derive [                                     # This adds columns / variables.
  gross_salary: salary + payroll_tax,
  gross_cost:  gross_salary + benefits_cost  # Variables can use other variables.
]
filter gross_cost &gt; 0
group [title, country_code] (                # For each group use a nested pipeline
  aggregate [                                # Aggregate each group to a single row
    average salary,
    average gross_salary,
    sum salary,
    sum gross_salary,
    average gross_cost,
    sum_gross_cost: sum gross_cost,
    ct: count,
  ]
)
sort sum_gross_cost
filter ct &gt; 200
take 20
join countries side:left [country_code]
derive [
  always_true: true,
  db_version: s&quot;version()&quot;,                  # An S-string, which transpiles directly into SQL
]
</code></pre>
</td>
<td>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    title,
    country_code,
    AVG(salary),
    AVG(salary + payroll_tax),
    SUM(salary),
    SUM(salary + payroll_tax),
    AVG(salary + payroll_tax + benefits_cost),
    SUM(salary + payroll_tax + benefits_cost) AS sum_gross_cost,
    COUNT(*) AS ct
  FROM
    employees
  WHERE
    country_code = 'USA'
    AND salary + payroll_tax + benefits_cost &gt; 0
  GROUP BY
    title,
    country_code
  HAVING
    COUNT(*) &gt; 200
  ORDER BY
    sum_gross_cost
  LIMIT
    20
)
SELECT
  table_0.*,
  countries.*,
  country_code,
  countries.true AS always_true,
  version() AS db_version
FROM
  table_0
  LEFT JOIN countries USING(country_code)
</code></pre>
</td>
</tr>
</table>
</div>
<p>As you can see, PRQL is a linear <strong>pipeline of transformations</strong> — each line of the
query is a transformation of the previous line's result.</p>
<p>You can see that in SQL, operations do not follow one another, which makes it hard to compose larger queries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>PRQL queries are structured differently to SQL queries — they represent a
pipeline of transformations, each one changing the previous result into a new
result.</p>
<ul>
<li><a href="queries/pipelines.html">Pipelines</a></li>
</ul>
<p>[TODO]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipelines"><a class="header" href="#pipelines">Pipelines</a></h1>
<h3 id="the-simplest-pipeline"><a class="header" href="#the-simplest-pipeline">The simplest pipeline</a></h3>
<p>The simplest pipeline is just:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
</code></pre>
</td>
</tr>
</table>
</div>
<h3 id="adding-transformations"><a class="header" href="#adding-transformations">Adding transformations</a></h3>
<p>We can add additional lines, each one transforms the result:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
derive gross_salary: (salary + payroll_tax)
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary
FROM
  employees
</code></pre>
</td>
</tr>
</table>
</div>
<p>...and so on:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
derive gross_salary: (salary + payroll_tax)
sort gross_salary
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary
FROM
  employees
ORDER BY
  gross_salary
</code></pre>
</td>
</tr>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-features"><a class="header" href="#language-features">Language Features</a></h1>
<p>PRQL improves on many of SQL's awkward language features:</p>
<!-- toc -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-strings"><a class="header" href="#f-strings">F-Strings</a></h1>
<p>f-strings are a readable approach to building new strings from existing strings.
Currently PRQL supports this for concatenating strings:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from x
select full_name: f&quot;{first} {last}&quot;
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  CONCAT(first, ' ', last) AS full_name
FROM
  x
</code></pre>
</td>
</tr>
</table>
</div>
<p>This can be much easier to read for longer strings, relative to the SQL approach:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from x
select url: f&quot;http{tls}://www.{domain}.{tld}/{page}&quot;
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  CONCAT(
    'http',
    tls,
    '://www.',
    domain,
    '.',
    tld,
    '/',
    page
  ) AS url
FROM
  x
</code></pre>
</td>
</tr>
</table>
</div>
<p>In the future, this may extend to other types of formatting, such as datetimes,
numbers, and padding. If there's a feature that would be helpful, please <a href="https://github.com/prql/prql/issues/new/choose">post
an issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ranges"><a class="header" href="#ranges">Ranges</a></h1>
<p>PRQL has a concise range syntax <code>start..end</code>, which can be accessed with the <code>in</code> function:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
filter (age | in 18..40)
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
WHERE
  age BETWEEN 18
  AND 40
</code></pre>
</td>
</tr>
</table>
</div>
<p>Like in SQL, ranges are inclusive.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dates"><a class="header" href="#dates">Dates</a></h1>
<h2 id="intervals"><a class="header" href="#intervals">Intervals</a></h2>
<p>Intervals are represented by <code>{N}{periods}</code>, such as <code>2years</code> or <code>10minutes</code>,
without a space.</p>
<blockquote>
<p>These aren't the same as ISO8601, because we evaluated <code>P3Y6M4DT12H30M5S</code> to
be difficult to understand, but we could support a simplified form if there's
demand for it. We don't currently support compound expressions, for example
<code>2years10months</code>, but most DBs will allow <code>2years + 10months</code>. Please raise an
issue if this is inconvenient.</p>
</blockquote>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from projects
derive first_check_in: start + 10days
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  projects.*,
  start + INTERVAL '10' DAY AS first_check_in
FROM
  projects
</code></pre>
</td>
</tr>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="s-strings"><a class="header" href="#s-strings">S-Strings</a></h1>
<p>An s-string inserts SQL directly, as an escape hatch when there's something that PRQL
doesn't yet implement. For example, there's no <code>version()</code> function in SQL that
returns the Postgres version, so if we want to use that, we use an s-string:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">derive db_version: s&quot;version()&quot;
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  version() AS db_version
</code></pre>
</td>
</tr>
</table>
</div>
<p>We can embed columns in an s-string using braces. For example, PRQL's standard
library defines the <code>average</code> function as:</p>
<pre><code class="language-prql_no_test">func average column = s&quot;AVG({column})&quot;
</code></pre>
<p>So this compiles using the function:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
aggregate [average salary]
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  AVG(salary)
FROM
  employees
</code></pre>
</td>
</tr>
</table>
</div>
<p>For those who have used python, s-strings are similar to python f-strings, but
the result is SQL, rather than a string literal — a python f-string would
produce <code>&quot;average(salary)&quot;</code>, with the quotes.</p>
<p>S-strings in user code are intended as an escape-hatch for an unimplemented
feature. If we often need s-strings to express something, that's a sign we
should implement it in PRQL / PRQL's stdlib.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transforms"><a class="header" href="#transforms">Transforms</a></h1>
<p>Core principle of the language is a pipeline, which is a series of sequential transformations of a table (or data frame). There is only a few different types of transformations:</p>
<h2 id="from"><a class="header" href="#from">From</a></h2>
<blockquote>
<p>specifies a data source</p>
</blockquote>
<pre><code class="language-prql_no_test">from {table reference}
</code></pre>
<p><em>Example:</em></p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
</code></pre>
</td>
</tr>
</table>
</div>
<h2 id="select"><a class="header" href="#select">Select</a></h2>
<blockquote>
<p>picks columns based on their names</p>
</blockquote>
<pre><code class="language-prql_no_test">select [{expression}]
</code></pre>
<p><em>Example:</em></p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
select [first_name, last_name]
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees
</code></pre>
</td>
</tr>
</table>
</div>
<h2 id="derive"><a class="header" href="#derive">Derive</a></h2>
<blockquote>
<p>adds new columns that are computed from existing columns</p>
</blockquote>
<pre><code class="language-prql_no_test">derive [{new_name}: {expression}]
</code></pre>
<p><em>Example:</em></p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
derive gross_salary: salary + payroll_tax
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary
FROM
  employees
</code></pre>
</td>
</tr>
</table>
</div>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
derive [
  gross_salary: salary + payroll_tax,
  gross_cost: gross_salary + benefits_cost
]
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary,
  gross_salary + benefits_cost AS gross_cost
FROM
  employees
</code></pre>
</td>
</tr>
</table>
</div>
<h2 id="filter"><a class="header" href="#filter">Filter</a></h2>
<blockquote>
<p>picks rows based on their values</p>
</blockquote>
<pre><code class="language-prql_no_test">filter {boolean expression}
</code></pre>
<p><em>Example:</em></p>
<pre><code class="language-prql_no_test">from employees
filter (length last_name &lt; 3)
</code></pre>
<h2 id="take"><a class="header" href="#take">Take</a></h2>
<blockquote>
<p>picks first n rows</p>
</blockquote>
<pre><code class="language-prql_no_test">take {n}
</code></pre>
<p><em>Example:</em></p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
take 10
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
LIMIT
  10
</code></pre>
</td>
</tr>
</table>
</div>
<h2 id="sort"><a class="header" href="#sort">Sort</a></h2>
<blockquote>
<p>orders the rows by the values of selected columns</p>
</blockquote>
<pre><code class="language-prql_no_test">sort {column}
</code></pre>
<p><em>Arguments:</em></p>
<ul>
<li>a column identifier of the key to sort by</li>
</ul>
<p><em>Example:</em></p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
sort age
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
ORDER BY
  age
</code></pre>
</td>
</tr>
</table>
</div>
<h2 id="join"><a class="header" href="#join">Join</a></h2>
<blockquote>
<p>adds columns from another table, matching rows based on a condition</p>
</blockquote>
<pre><code class="language-prql_no_test">join side:{inner|left|right|full} {table} {[conditions]}
</code></pre>
<p><em>Arguments:</em></p>
<ul>
<li><code>side</code> decides which rows to include. Defaults to <code>inner</code></li>
<li>table reference</li>
<li>list of conditions
<ul>
<li>If all terms are column identifiers, this will compile to <code>USING(...)</code>. In this case, both of the tables must have specified column. The result will only contain one column instead one for each table.</li>
</ul>
</li>
</ul>
<p><em>Example:</em></p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
join side:left positions [id=employee_id]
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  employees.*,
  positions.*
FROM
  employees
  LEFT JOIN positions ON id = employee_id
</code></pre>
</td>
</tr>
</table>
</div>
<p><em>Example:</em></p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
join side:full positions [emp_no]
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  employees.*,
  positions.*,
  emp_no
FROM
  employees FULL
  JOIN positions USING(emp_no)
</code></pre>
</td>
</tr>
</table>
</div>
<h2 id="group"><a class="header" href="#group">Group</a></h2>
<p>A <code>group</code> transform maps a pipeline over a number of groups. The groups are determined by the
columns passed to <code>group</code>'s first argument.</p>
<p>The most conventional use of <code>group</code> is with <code>aggregate</code>:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
group [title, country] (
  aggregate [
    average salary,
    ct: count
  ]
)
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country
</code></pre>
</td>
</tr>
</table>
</div>
<p>In concept, a transform in context of a <code>group</code> does the same transformation to the group as
it would to the table — for example finding the employee who joined first:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
sort join_date
take 1
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
ORDER BY
  join_date
LIMIT
  1
</code></pre>
</td>
</tr>
</table>
</div>
<p>To find the employee who joined first in each department, it's exactly the
same pipeline, but within a <code>group</code> expression:</p>
<blockquote>
<p>Not yet implemented, ref <a href="https://github.com/prql/prql/issues/421">https://github.com/prql/prql/issues/421</a></p>
</blockquote>
<pre><code class="language-prql_no_test">from employees
group role (
  sort join_date  # taken from above
  take 1
)
</code></pre>
<h2 id="aggregate"><a class="header" href="#aggregate">Aggregate</a></h2>
<blockquote>
<p>group rows by one or more columns</p>
</blockquote>
<pre><code class="language-prql_no_test">aggregate [{expression or assign operations}]
</code></pre>
<p><em>Example:</em></p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from employees
aggregate [
  average salary,
  ct: count
]
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
</code></pre>
</td>
</tr>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<!-- Here we could explain how function parameters work, what is a list, S-strings, how to do aliases and so on. -->
<h3 id="lists"><a class="header" href="#lists">Lists</a></h3>
<ul>
<li>
<p>Most keywords that take a single argument can also take a list, so these are equivalent:</p>
<pre><code class="language-diff"> from employees
-select salary
+select [salary]
</code></pre>
</li>
<li>
<p>More examples in <a href="examples/list-equivalence.html"><strong>list-equivalence.md</strong></a>.</p>
</li>
</ul>
<h3 id="pipelines-1"><a class="header" href="#pipelines-1">Pipelines</a></h3>
<ul>
<li>
<p>A line-break generally creates a pipelined transformation. For example:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from tbl
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  tbl.*
FROM
  tbl
</code></pre>
</td>
</tr>
</table>
</div>
  col1,
  col2,
\]
filter col1 = col2
````
<p>...is equivalent to:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">from tbl | select [col1, col2] | filter col1 = col2
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  col1,
  col2
FROM
  tbl
WHERE
  col1 = col2
</code></pre>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>A line-break doesn't created a pipeline in a few cases:</p>
<ul>
<li>Within a list (e.g. the <code>select</code> example above).</li>
<li>When the following line is a new statement, by starting with a keyword such
as <code>func</code>.</li>
</ul>
</li>
</ul>
<h3 id="ctes"><a class="header" href="#ctes">CTEs</a></h3>
<ul>
<li>See <a href="examples/cte-1.html">CTE Example</a>.</li>
<li>This is no longer point-free, but that's a feature rather than a requirement.
The alternative is subqueries, which are fine at small scale, but become
difficult to digest as complexity increases.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<!--
TODOs:
- Examples are a bit artificial — the interp is just "divide by 100" in one case!  -->
<p>Functions are a fundamental abstraction in PRQL — they allow us to run code in
many places that we've written once. This reduces the number of errors in our
code, makes our code more readable, and simplifies making changes.</p>
<p>Functions have two types of parameters:</p>
<ol>
<li>Positional parameters, which require an argument.</li>
<li>Named parameters, which optionally take an argument, otherwise using their
default value.</li>
</ol>
<p>So this function is named <code>celsius_of_fahrenheit</code> and has one parameter <code>temp</code>:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">func celsius_of_fahrenheit temp = (temp - 32) * 3

from cities
derive temp_c: (celsius_of_fahrenheit temp_f)
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  cities.*,
  temp_f - 32 * 3 AS temp_c
FROM
  cities
</code></pre>
</td>
</tr>
</table>
</div>
<p>This function named <code>interp</code>, and has two positional parameters named
<code>higher</code> and <code>x</code>, and one named parameter named <code>lower</code> which takes a default
argument of <code>0</code>. It calculates the proportion of the distance that <code>x</code> is
between <code>lower</code> and <code>higher</code>.</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">func interp lower:0 higher x = (x - lower) / (higher - lower)

from students
derive [
  sat_proportion_1: (interp 1600 sat_score),
  sat_proportion_2: (interp lower:0 1600 sat_score),
]
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  students.*,
  sat_score - 0 / 1600 - 0 AS sat_proportion_1,
  sat_score - 0 / 1600 - 0 AS sat_proportion_2
FROM
  students
</code></pre>
</td>
</tr>
</table>
</div>
<h2 id="piping"><a class="header" href="#piping">Piping</a></h2>
<p>Consistent with the principles of PRQL, it's possible to pipe values into
functions, which makes composing functions more readable. When piping a value
into a function, the value is passed as an argument to the final positional
parameter of the function. Here's the same result as the examples above with an
alternative construction:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">func interp lower:0 higher x = (x - lower) / (higher - lower)

from students
derive [
  sat_proportion_1: (sat_score | interp 1600),
  sat_proportion_2: (sat_score | interp lower:0 1600),
]
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  students.*,
  sat_score - 0 / 1600 - 0 AS sat_proportion_1,
  sat_score - 0 / 1600 - 0 AS sat_proportion_2
FROM
  students
</code></pre>
</td>
</tr>
</table>
</div>
<p>and</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">func celsius_of_fahrenheit temp = (temp - 32) * 3

from cities
derive temp_c: (temp_f | celsius_of_fahrenheit)
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  cities.*,
  temp_f - 32 * 3 AS temp_c
FROM
  cities
</code></pre>
</td>
</tr>
</table>
</div>
<p>We can combine a chain of functions, which makes logic more readable:</p>
<div class="comparison">
<table>
<tr>
<th>PRQL</th><th>SQL</th>
</tr>
<tr>
<td>
<pre><code class="language-prql">func celsius_of_fahrenheit temp = (temp - 32) * 3
func interp lower:0 higher x = (x - lower) / (higher - lower)

from kettles
derive boiling_proportion: (temp_c | celsius_of_fahrenheit | interp 100)
</code></pre>
</td>
<td>
<pre><code class="language-sql">SELECT
  kettles.*,
  temp_c - 32 * 3 - 0 / 100 - 0 AS boiling_proportion
FROM
  kettles
</code></pre>
</td>
</tr>
</table>
</div>
<h2 id="todos"><a class="header" href="#todos">TODOs</a></h2>
<p>Currently, functions require a binding to variables in scope; they can't
late-bind to column names; so for example:</p>
<pre><code class="language-prql_no_test">func return price = (price - dividend) / price_yesterday
</code></pre>
<p>...isn't yet a valid function, and instead would needs to be:</p>
<pre><code class="language-prql_no_test">func return price dividend price_yesterday = (price - dividend) / (price_yesterday)
</code></pre>
<p>(which makes functions in this case not useful)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdlib"><a class="header" href="#stdlib">Stdlib</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="live-editor"><a class="header" href="#live-editor">Live Editor</a></h1>
<!-- The `container-container` properties already exist on `editor-container`, but we
need to re-specify them since there's another layer (maybe avoidable?). -->
<!-- We specify all the hierarchy, from html down, to have height=100%, in order to
get the editors to be full height, and add some reductions in `px` to two
elements, to prevent scroll bars / awkward scrolling when the line breaks run
on. We previously had a different approach, which aligned the content such that
we didn't need scrollbars, but it didn't work well on Chrome. -->
<!-- TODO:
- Should we have a max-width to limit the width for very wide browsers?
- If so, can we get the editors to center?
 -->
<style>
    html, body, .page-wrapper, .page , .container-container {
        height: 100%;
        box-sizing: border-box;
    }
     main {
        height: calc(100% - 150px);
        box-sizing: border-box;
    }
    .content {
        height: calc(100% - 70px);
        box-sizing: border-box;
    }
    main {
        /*Override the main CSS so that the Editors can be wide*/
        max-width: none !important;
    }
    .container-container {
        width: 100%;
    }
    .nav-chapters, .nav-wrapper {
        visibility: hidden;
    }
</style>
<embed class="container-container" type="text/html" src="./dist/index.html">

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="highlight-prql.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
