<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PRQL Language Reference (draft)</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Modern language for transforming data — a simpler and more powerful SQL">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="comparison-table.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="queries/index.html"><strong aria-hidden="true">2.</strong> Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="queries/pipelines.html"><strong aria-hidden="true">2.1.</strong> Pipelines</a></li></ol></li><li class="chapter-item expanded "><a href="transforms.html"><strong aria-hidden="true">3.</strong> Transforms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="transforms/from.html"><strong aria-hidden="true">3.1.</strong> From</a></li><li class="chapter-item expanded "><a href="transforms/select.html"><strong aria-hidden="true">3.2.</strong> Select</a></li><li class="chapter-item expanded "><a href="transforms/derive.html"><strong aria-hidden="true">3.3.</strong> Derive</a></li><li class="chapter-item expanded "><a href="transforms/filter.html"><strong aria-hidden="true">3.4.</strong> Filter</a></li><li class="chapter-item expanded "><a href="transforms/sort.html"><strong aria-hidden="true">3.5.</strong> Sort</a></li><li class="chapter-item expanded "><a href="transforms/join.html"><strong aria-hidden="true">3.6.</strong> Join</a></li><li class="chapter-item expanded "><a href="transforms/take.html"><strong aria-hidden="true">3.7.</strong> Take</a></li><li class="chapter-item expanded "><a href="transforms/group.html"><strong aria-hidden="true">3.8.</strong> Group</a></li><li class="chapter-item expanded "><a href="transforms/aggregate.html"><strong aria-hidden="true">3.9.</strong> Aggregate</a></li><li class="chapter-item expanded "><a href="transforms/window.html"><strong aria-hidden="true">3.10.</strong> Window</a></li></ol></li><li class="chapter-item expanded "><a href="language-features/index.html"><strong aria-hidden="true">4.</strong> Language features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language-features/strings.html"><strong aria-hidden="true">4.1.</strong> Strings</a></li><li class="chapter-item expanded "><a href="language-features/f-strings.html"><strong aria-hidden="true">4.2.</strong> F-Strings</a></li><li class="chapter-item expanded "><a href="language-features/s-strings.html"><strong aria-hidden="true">4.3.</strong> S-Strings</a></li><li class="chapter-item expanded "><a href="language-features/ranges.html"><strong aria-hidden="true">4.4.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="language-features/dates_and_times.html"><strong aria-hidden="true">4.5.</strong> Dates & Times</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Regex</div></li><li class="chapter-item expanded "><a href="language-features/coalesce.html"><strong aria-hidden="true">4.7.</strong> Coalesce</a></li></ol></li><li class="chapter-item expanded "><a href="syntax.html"><strong aria-hidden="true">5.</strong> Syntax</a></li><li class="chapter-item expanded "><a href="null.html"><strong aria-hidden="true">6.</strong> Null handling</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="stdlib.html"><strong aria-hidden="true">8.</strong> Stdlib</a></li><li class="chapter-item expanded "><a href="editor.html"><strong aria-hidden="true">9.</strong> Live Editor</a></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">10.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/variables.html"><strong aria-hidden="true">10.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="examples/list-equivalence.html"><strong aria-hidden="true">10.2.</strong> List equivalence</a></li><li class="chapter-item expanded "><a href="examples/functions.html"><strong aria-hidden="true">10.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="examples/cte.html"><strong aria-hidden="true">10.4.</strong> CTE (intermediate tables)</a></li><li class="chapter-item expanded "><a href="examples/sql-parameters.html"><strong aria-hidden="true">10.5.</strong> Sql parameters</a></li><li class="chapter-item expanded "><a href="examples/employees.html"><strong aria-hidden="true">10.6.</strong> Employees</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PRQL Language Reference (draft)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/prql/prql" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<blockquote>
<p>[Note that this is a very early version and actively being worked on; thanks for
your patience]</p>
</blockquote>
<p>PRQL is a modern language for transforming data — a simpler and more powerful
SQL. Like SQL, it's readable, explicit and declarative. Unlike SQL, it forms a
logical pipeline of transformations, and supports abstractions such as variables
and functions. It can be used with any database that uses SQL, since it
transpiles to SQL.</p>
<p>Let's get started with an example:</p>
<!-- TODO: resolve formatting — way too wide for the current preprocessor -->
<div class="comparison">
<div>
<h4 id="prql"><a class="header" href="#prql">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter country_code == &quot;USA&quot;   # Each line transforms the previous result.
derive [                       # This adds columns / variables.
  gross_salary = salary + payroll_tax,
  gross_cost = gross_salary + benefits_cost  # Variables can use other variables.
]
filter gross_cost &gt; 0
group [title, country_code] (  # For each group use a nested pipeline
  aggregate [                  # Aggregate each group to a single row
    average salary,
    average gross_salary,
    sum salary,
    sum gross_salary,
    average gross_cost,
    sum_gross_cost = sum gross_cost,
    ct = count,
  ]
)
sort sum_gross_cost
filter ct &gt; 200
take 20
join countries side:left [country_code]
derive [
  always_true = true,
  db_version = s&quot;version()&quot;,    # An S-string, which transpiles directly into SQL
]
</code></pre>
</div>
<div>
<h4 id="sql"><a class="header" href="#sql">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    title,
    country_code,
    AVG(salary),
    AVG(salary + payroll_tax),
    SUM(salary),
    SUM(salary + payroll_tax),
    AVG(salary + payroll_tax + benefits_cost),
    SUM(salary + payroll_tax + benefits_cost) AS sum_gross_cost,
    COUNT(*) AS ct
  FROM
    employees
  WHERE
    country_code = 'USA'
    AND salary + payroll_tax + benefits_cost &gt; 0
  GROUP BY
    title,
    country_code
  HAVING
    COUNT(*) &gt; 200
  ORDER BY
    sum_gross_cost
  LIMIT
    20
)
SELECT
  table_0.*,
  countries.*,
  country_code,
  true AS always_true,
  version() AS db_version
FROM
  table_0
  LEFT JOIN countries USING(country_code)
</code></pre>
</div>
</div>
<p>As you can see, PRQL is a linear <strong>pipeline of transformations</strong> — each line of the
query is a transformation of the previous line's result.</p>
<p>You can see that in SQL, operations do not follow one another, which makes it hard to compose larger queries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>PRQL queries are structured differently to SQL queries — they represent a
pipeline of transformations, each one changing the previous result into a new
result.</p>
<ul>
<li><a href="queries/pipelines.html">Pipelines</a></li>
</ul>
<p>[TODO]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipelines"><a class="header" href="#pipelines">Pipelines</a></h1>
<h3 id="the-simplest-pipeline"><a class="header" href="#the-simplest-pipeline">The simplest pipeline</a></h3>
<p>The simplest pipeline is just:</p>
<div class="comparison">
<div>
<h4 id="prql-1"><a class="header" href="#prql-1">PRQL</a></h4>
<pre><code class="language-prql">from employees
</code></pre>
</div>
<div>
<h4 id="sql-1"><a class="header" href="#sql-1">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
</code></pre>
</div>
</div>
<h3 id="adding-transformations"><a class="header" href="#adding-transformations">Adding transformations</a></h3>
<p>We can add additional lines, each one transforms the result:</p>
<div class="comparison">
<div>
<h4 id="prql-2"><a class="header" href="#prql-2">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive gross_salary = (salary + payroll_tax)
</code></pre>
</div>
<div>
<h4 id="sql-2"><a class="header" href="#sql-2">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary
FROM
  employees
</code></pre>
</div>
</div>
<p>...and so on:</p>
<div class="comparison">
<div>
<h4 id="prql-3"><a class="header" href="#prql-3">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive gross_salary = (salary + payroll_tax)
sort gross_salary
</code></pre>
</div>
<div>
<h4 id="sql-3"><a class="header" href="#sql-3">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary
FROM
  employees
ORDER BY
  gross_salary
</code></pre>
</div>
</div>
<p>PRQL compiler will try to represent as many transforms as possible with a single <code>SELECT</code> statement, and uses CTE (common table expression) for complex pipelines:</p>
<div class="comparison">
<div>
<h4 id="prql-4"><a class="header" href="#prql-4">PRQL</a></h4>
<pre><code class="language-prql">from e = employees
derive gross_salary = (salary + payroll_tax)
sort gross_salary
take 10
join d = department [dept_no]
select [e.name, gross_salary, d.name]
</code></pre>
</div>
<div>
<h4 id="sql-4"><a class="header" href="#sql-4">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    e.*,
    salary + payroll_tax AS gross_salary
  FROM
    employees AS e
  ORDER BY
    gross_salary
  LIMIT
    10
)
SELECT
  table_0.name,
  table_0.gross_salary,
  d.name
FROM
  table_0
  JOIN department AS d USING(dept_no)
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transforms"><a class="header" href="#transforms">Transforms</a></h1>
<p>PRQL queries are a pipeline of transformations (&quot;transforms&quot;), where each transform takes
the previous result and adjusts it in some way, before passing it onto to the
next transform.</p>
<p>Because PRQL focuses on modularity, we have far fewer transforms than SQL, each
one fulfilling a specific purpose. That's often referred to as &quot;orthogonality&quot;.</p>
<p>These are the currently available transforms:</p>
<!-- Copied from `SUMMARY.md` -->
<p>| Transform                   | Purpose                                                             |
| --------------------------- | ------------------------------------------------------------------- |
| <a href="./derive.html">Derive</a>       | Computes new columns                                                |
| <a href="./select.html">Select</a>       | Picks &amp; computes columns                                            |
| <a href="./filter.html">Filter</a>       | Picks rows based on their values                                    |
| <a href="./sort.html">Sort</a>           | Orders rows based on the values of columns                          |
| <a href="./join.html">Join</a>           | Adds columns from another table, matching rows based on a condition |
| <a href="./take.html">Take</a>           | Picks rows based on their position                                  |
| <a href="./group.html">Group</a>         | Partitions rows into groups and applies a pipeline to each of them  |
| <a href="./aggregate.html">Aggregate</a> | Summarizes many rows into one row                                   |
| <a href="./window.html">Window</a>       | Applies a pipeline to overlapping segments of rows                  |</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from"><a class="header" href="#from">From</a></h1>
<p>Specifies a data source.</p>
<pre><code class="language-prql_no_test">from {table_reference}
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-5"><a class="header" href="#prql-5">PRQL</a></h4>
<pre><code class="language-prql">from employees
</code></pre>
</div>
<div>
<h4 id="sql-5"><a class="header" href="#sql-5">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
</code></pre>
</div>
</div>
<p>To introduce an alias, use an assign expression:</p>
<div class="comparison">
<div>
<h4 id="prql-6"><a class="header" href="#prql-6">PRQL</a></h4>
<pre><code class="language-prql">from e = employees
select e.first_name
</code></pre>
</div>
<div>
<h4 id="sql-6"><a class="header" href="#sql-6">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees AS e
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">Select</a></h1>
<p>Picks and compute columns.</p>
<pre><code class="language-prql_no_test">select [{assign_expression}]
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-7"><a class="header" href="#prql-7">PRQL</a></h4>
<pre><code class="language-prql">from employees
select first_name
</code></pre>
</div>
<div>
<h4 id="sql-7"><a class="header" href="#sql-7">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-8"><a class="header" href="#prql-8">PRQL</a></h4>
<pre><code class="language-prql">from employees
select [first_name, last_name]
</code></pre>
</div>
<div>
<h4 id="sql-8"><a class="header" href="#sql-8">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-9"><a class="header" href="#prql-9">PRQL</a></h4>
<pre><code class="language-prql">from employees
select name = f&quot;{first_name} {last_name}&quot;
</code></pre>
</div>
<div>
<h4 id="sql-9"><a class="header" href="#sql-9">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS name
FROM
  employees
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-10"><a class="header" href="#prql-10">PRQL</a></h4>
<pre><code class="language-prql">from employees
select [
  name = f&quot;{first_name} {last_name}&quot;,
  age_eoy = dob - @2022-12-31,
]
</code></pre>
</div>
<div>
<h4 id="sql-10"><a class="header" href="#sql-10">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS name,
  dob - DATE '2022-12-31' AS age_eoy
FROM
  employees
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive"><a class="header" href="#derive">Derive</a></h1>
<p>Computes one or more new columns.</p>
<pre><code class="language-prql_no_test">derive [{new_name} = {expression}]
</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-11"><a class="header" href="#prql-11">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive gross_salary = salary + payroll_tax
</code></pre>
</div>
<div>
<h4 id="sql-11"><a class="header" href="#sql-11">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary
FROM
  employees
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-12"><a class="header" href="#prql-12">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive [
  gross_salary = salary + payroll_tax,
  gross_cost = gross_salary + benefits_cost
]
</code></pre>
</div>
<div>
<h4 id="sql-12"><a class="header" href="#sql-12">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary,
  salary + payroll_tax + benefits_cost AS gross_cost
FROM
  employees
</code></pre>
</div>
</div>
<p>It generally computes a column from existing columns, but can also take a
literal, and doesn't require a <code>from</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-13"><a class="header" href="#prql-13">PRQL</a></h4>
<pre><code class="language-prql">derive x = 5
</code></pre>
</div>
<div>
<h4 id="sql-13"><a class="header" href="#sql-13">SQL</a></h4>
<pre><code class="language-sql">SELECT
  5 AS x
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filter"><a class="header" href="#filter">Filter</a></h1>
<p>Picks rows based on their values.</p>
<pre><code class="language-prql_no_test">filter {boolean_expression}
</code></pre>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-14"><a class="header" href="#prql-14">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter age &gt; 25
</code></pre>
</div>
<div>
<h4 id="sql-14"><a class="header" href="#sql-14">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
WHERE
  age &gt; 25
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-15"><a class="header" href="#prql-15">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter (age | in 25..40)
</code></pre>
</div>
<div>
<h4 id="sql-15"><a class="header" href="#sql-15">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
WHERE
  age BETWEEN 25
  AND 40
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sort"><a class="header" href="#sort">Sort</a></h1>
<p>Orders rows based on the values of one or more columns.</p>
<pre><code class="language-prql_no_test">sort [{direction}{column}]
</code></pre>
<h2 id="arguments"><a class="header" href="#arguments">Arguments</a></h2>
<ul>
<li>One or multiple columns</li>
<li>Each column can be prefixed with:
<ul>
<li><code>+</code>, for ascending order, the default</li>
<li><code>-</code>, for descending order</li>
</ul>
</li>
</ul>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-16"><a class="header" href="#prql-16">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort age
</code></pre>
</div>
<div>
<h4 id="sql-16"><a class="header" href="#sql-16">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
ORDER BY
  age
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-17"><a class="header" href="#prql-17">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort (-age)
</code></pre>
</div>
<div>
<h4 id="sql-17"><a class="header" href="#sql-17">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
ORDER BY
  age DESC
</code></pre>
</div>
</div>
<blockquote>
<p>Note that <code>sort -age</code> is not valid; <code>-age</code> needs to be surrounded by
parentheses like `(-age).</p>
</blockquote>
<div class="comparison">
<div>
<h4 id="prql-18"><a class="header" href="#prql-18">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort [age, -tenure, +salary]
</code></pre>
</div>
<div>
<h4 id="sql-18"><a class="header" href="#sql-18">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
ORDER BY
  age,
  tenure DESC,
  salary
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="join"><a class="header" href="#join">Join</a></h1>
<p>Adds columns from another table, matching rows based on a condition.</p>
<pre><code class="language-prql_no_test">join side:{inner|left|right|full} {table} {[conditions]}
</code></pre>
<h2 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h2>
<ul>
<li><code>side</code> decides which rows to include. Defaults to <code>inner</code></li>
<li>Table reference</li>
<li>List of conditions
<ul>
<li>If all terms are column identifiers, this will compile to <code>USING(...)</code>. In
this case, both of the tables must have specified column. The result will
only contain one column for both tables.</li>
</ul>
</li>
</ul>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-19"><a class="header" href="#prql-19">PRQL</a></h4>
<pre><code class="language-prql">from employees
join side:left positions [id==employee_id]
</code></pre>
</div>
<div>
<h4 id="sql-19"><a class="header" href="#sql-19">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  positions.*
FROM
  employees
  LEFT JOIN positions ON id = employee_id
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-20"><a class="header" href="#prql-20">PRQL</a></h4>
<pre><code class="language-prql">from employees
join side:full positions [emp_no]
</code></pre>
</div>
<div>
<h4 id="sql-20"><a class="header" href="#sql-20">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  positions.*,
  emp_no
FROM
  employees FULL
  JOIN positions USING(emp_no)
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-21"><a class="header" href="#prql-21">PRQL</a></h4>
<pre><code class="language-prql">from employees
join side:left p=positions [id==employee_id]
</code></pre>
</div>
<div>
<h4 id="sql-21"><a class="header" href="#sql-21">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  p.*
FROM
  employees
  LEFT JOIN positions AS p ON id = employee_id
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="take"><a class="header" href="#take">Take</a></h1>
<p>Picks rows based on their position.</p>
<pre><code class="language-prql_no_test">take {n}
</code></pre>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-22"><a class="header" href="#prql-22">PRQL</a></h4>
<pre><code class="language-prql">from employees
take 10
</code></pre>
</div>
<div>
<h4 id="sql-22"><a class="header" href="#sql-22">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
LIMIT
  10
</code></pre>
</div>
</div>
<h2 id="todo"><a class="header" href="#todo">Todo</a></h2>
<p>We could support a range expression so we can get an offset:</p>
<pre><code class="language-prql_no_test">from employees
take 1..10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="group"><a class="header" href="#group">Group</a></h1>
<p>Partitions the rows into groups and applies a pipeline to each of the groups.</p>
<pre><code class="language-prql_no_test">group [{key column}] {pipeline}
</code></pre>
<p>The partitioning of groups are determined by the <code>key column</code>s (first argument).</p>
<p>The most conventional use of <code>group</code> is with <code>aggregate</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-23"><a class="header" href="#prql-23">PRQL</a></h4>
<pre><code class="language-prql">from employees
group [title, country] (
  aggregate [
    average salary,
    ct = count
  ]
)
</code></pre>
</div>
<div>
<h4 id="sql-23"><a class="header" href="#sql-23">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country
</code></pre>
</div>
</div>
<p>In concept, a transform in context of a <code>group</code> does the same transformation to the group as
it would to the table — for example finding the employee who joined first:</p>
<div class="comparison">
<div>
<h4 id="prql-24"><a class="header" href="#prql-24">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort join_date
take 1
</code></pre>
</div>
<div>
<h4 id="sql-24"><a class="header" href="#sql-24">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
ORDER BY
  join_date
LIMIT
  1
</code></pre>
</div>
</div>
<p>To find the employee who joined first in each department, it's exactly the
same pipeline, but within a <code>group</code> expression:</p>
<blockquote>
<p>Not yet implemented, ref <a href="https://github.com/prql/prql/issues/421">https://github.com/prql/prql/issues/421</a></p>
</blockquote>
<pre><code class="language-prql_no_test">from employees
group role (
  sort join_date  # taken from above
  take 1
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="aggregate"><a class="header" href="#aggregate">Aggregate</a></h2>
<p>Summarizes many rows into one row.</p>
<p>When applied:</p>
<ul>
<li>without <code>group</code>, it produces one row from the whole table,</li>
<li>within a <code>group</code> pipeline, it produces one row from each group.</li>
</ul>
<pre><code class="language-prql_no_test">aggregate [{expression or assign operations}]
</code></pre>
<h4 id="examples-7"><a class="header" href="#examples-7">Examples</a></h4>
<div class="comparison">
<div>
<h4 id="prql-25"><a class="header" href="#prql-25">PRQL</a></h4>
<pre><code class="language-prql">from employees
aggregate [
  average salary,
  ct = count
]
</code></pre>
</div>
<div>
<h4 id="sql-25"><a class="header" href="#sql-25">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window"><a class="header" href="#window">Window</a></h1>
<p>Applies a pipeline to overlapping segments of rows.</p>
<pre><code class="language-prql_no_test">window rows:.. range:.. expanding:false rolling:0 {pipeline}
</code></pre>
<p>For each row in result, its input segment is determined either by:</p>
<ul>
<li><code>rows</code>, which takes a range of rows relative to current row,</li>
<li><code>range</code>, which takes a range of values relative to current row value.</li>
</ul>
<p>Start of the range is inclusive, end of range is exclusive. Index 0 references
current row. If a bound is omitted, segment will extend until the end of the table (or group).</p>
<p>For example:</p>
<ul>
<li><code>rows:0..3</code>   means current row plus two following,</li>
<li><code>rows:-2..1</code>  means two preceding rows plus current row,</li>
<li><code>rows:-2..5</code>  means two preceding rows plus current row plus four following rows,</li>
<li><code>rows:..1</code>    means all rows from the start of the table to and including current row,</li>
<li><code>rows:0..</code>    means current row and all following rows until the end of the table,</li>
<li><code>rows:..</code>     means all rows, which same as not having window at all.</li>
</ul>
<blockquote>
<p>Note: currently, negative integer literals (<code>-3</code>) are not implemented.</p>
</blockquote>
<!-- TODO: rows vs range example, with visualization -->
<p>For ease of use, there are two flags that override <code>rows</code> or <code>range</code>:</p>
<ul>
<li><code>expanding:true</code> is an alias for <code>rows:..1</code>. Sum using this window is also known as &quot;cumulative sum&quot;.</li>
<li><code>rolling:x</code> is an alias for <code>row:(-x+1)..1</code>, where <code>x</code> is an integer. This will include <code>x</code> last values, including current row.</li>
</ul>
<blockquote>
<p>Note: this row and range notation makes it easy to determine total number of rows included: <code>end - start</code>. In contrast, SQL does not make this easy with</p>
<pre><code class="language-sql">BETWEEN 2 PRECEDING -- will include 3 rows
</code></pre>
<pre><code class="language-sql">BETWEEN 2 PRECEDING AND 1 FOLLOWING -- will include 4 rows
</code></pre>
</blockquote>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<div class="comparison">
<div>
<h4 id="prql-26"><a class="header" href="#prql-26">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort day
window rolling:3 (
  derive [total_last_3_days = sum price]
)
group [order_month] (
  sort day
  window expanding:true (
    derive [monthly_running_total = sum price]
  )
)
</code></pre>
</div>
<div>
<h4 id="sql-26"><a class="header" href="#sql-26">SQL</a></h4>
<pre><code class="language-sql">SELECT
  orders.*,
  SUM(price) OVER (
    ORDER BY
      day ROWS BETWEEN 2 PRECEDING
      AND CURRENT ROW
  ) AS total_last_3_days,
  SUM(price) OVER (
    PARTITION BY order_month
    ORDER BY
      day ROWS BETWEEN UNBOUNDED PRECEDING
      AND CURRENT ROW
  ) AS monthly_running_total
FROM
  orders
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-features"><a class="header" href="#language-features">Language Features</a></h1>
<p>PRQL improves on many of SQL's awkward language features:</p>
<!-- toc -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>Strings in PRQL can use either single or double quotes:</p>
<div class="comparison">
<div>
<h4 id="prql-27"><a class="header" href="#prql-27">PRQL</a></h4>
<pre><code class="language-prql">derive x = &quot;hello world&quot;
</code></pre>
</div>
<div>
<h4 id="sql-27"><a class="header" href="#sql-27">SQL</a></h4>
<pre><code class="language-sql">SELECT
  'hello world' AS x
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-28"><a class="header" href="#prql-28">PRQL</a></h4>
<pre><code class="language-prql">derive x = 'hello world'
</code></pre>
</div>
<div>
<h4 id="sql-28"><a class="header" href="#sql-28">SQL</a></h4>
<pre><code class="language-sql">SELECT
  'hello world' AS x
</code></pre>
</div>
</div>
<p>To quote a string containing quotes, either use the &quot;other&quot; type of quote, or
use three-or-more quotes, and close with the same number.</p>
<div class="comparison">
<div>
<h4 id="prql-29"><a class="header" href="#prql-29">PRQL</a></h4>
<pre><code class="language-prql">derive x = '&quot;hello world&quot;'
</code></pre>
</div>
<div>
<h4 id="sql-29"><a class="header" href="#sql-29">SQL</a></h4>
<pre><code class="language-sql">SELECT
  '&quot;hello world&quot;' AS x
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-30"><a class="header" href="#prql-30">PRQL</a></h4>
<pre><code class="language-prql">derive x = &quot;&quot;&quot;I said &quot;hello world&quot;!&quot;&quot;&quot;
</code></pre>
</div>
<div>
<h4 id="sql-30"><a class="header" href="#sql-30">SQL</a></h4>
<pre><code class="language-sql">SELECT
  'I said &quot;hello world&quot;!' AS x
</code></pre>
</div>
</div>
<p>Currently PRQL does not adjust escape characters during the compilation process.</p>
<p>Currently PRQL allows multiline strings with either a single character or
multiple character quotes. This may change for strings using a single character
quote in future versions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-strings"><a class="header" href="#f-strings">F-Strings</a></h1>
<p>f-strings are a readable approach to building new strings from existing strings.
Currently PRQL supports this for concatenating strings:</p>
<div class="comparison">
<div>
<h4 id="prql-31"><a class="header" href="#prql-31">PRQL</a></h4>
<pre><code class="language-prql">from x
select full_name = f&quot;{first} {last}&quot;
</code></pre>
</div>
<div>
<h4 id="sql-31"><a class="header" href="#sql-31">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first, ' ', last) AS full_name
FROM
  x
</code></pre>
</div>
</div>
<p>This can be much easier to read for longer strings, relative to the SQL approach:</p>
<div class="comparison">
<div>
<h4 id="prql-32"><a class="header" href="#prql-32">PRQL</a></h4>
<pre><code class="language-prql">from x
select url = f&quot;http{tls}://www.{domain}.{tld}/{page}&quot;
</code></pre>
</div>
<div>
<h4 id="sql-32"><a class="header" href="#sql-32">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(
    'http',
    tls,
    '://www.',
    domain,
    '.',
    tld,
    '/',
    page
  ) AS url
FROM
  x
</code></pre>
</div>
</div>
<p>In the future, this may extend to other types of formatting, such as datetimes,
numbers, and padding. If there's a feature that would be helpful, please <a href="https://github.com/prql/prql/issues/new/choose">post
an issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="s-strings"><a class="header" href="#s-strings">S-Strings</a></h1>
<p>An s-string inserts SQL directly, as an escape hatch when there's something that PRQL
doesn't yet implement. For example, there's no <code>version()</code> function in SQL that
returns the Postgres version, so if we want to use that, we use an s-string:</p>
<div class="comparison">
<div>
<h4 id="prql-33"><a class="header" href="#prql-33">PRQL</a></h4>
<pre><code class="language-prql">derive db_version = s&quot;version()&quot;
</code></pre>
</div>
<div>
<h4 id="sql-33"><a class="header" href="#sql-33">SQL</a></h4>
<pre><code class="language-sql">SELECT
  version() AS db_version
</code></pre>
</div>
</div>
<p>We can embed columns in an s-string using braces. For example, PRQL's standard
library defines the <code>average</code> function as:</p>
<pre><code class="language-prql_no_test">func average column -&gt; s&quot;AVG({column})&quot;
</code></pre>
<p>So this compiles using the function:</p>
<div class="comparison">
<div>
<h4 id="prql-34"><a class="header" href="#prql-34">PRQL</a></h4>
<pre><code class="language-prql">from employees
aggregate [average salary]
</code></pre>
</div>
<div>
<h4 id="sql-34"><a class="header" href="#sql-34">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary)
FROM
  employees
</code></pre>
</div>
</div>
<p>For those who have used python, s-strings are similar to python f-strings, but
the result is SQL, rather than a string literal — a python f-string would
produce <code>&quot;average(salary)&quot;</code>, with the quotes.</p>
<p>S-strings in user code are intended as an escape-hatch for an unimplemented
feature. If we often need s-strings to express something, that's a sign we
should implement it in PRQL / PRQL's stdlib.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ranges"><a class="header" href="#ranges">Ranges</a></h1>
<p>PRQL has a concise range syntax <code>start..end</code>, which can be accessed with the <code>in</code> function:</p>
<div class="comparison">
<div>
<h4 id="prql-35"><a class="header" href="#prql-35">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter (age | in 18..40)
</code></pre>
</div>
<div>
<h4 id="sql-35"><a class="header" href="#sql-35">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
WHERE
  age BETWEEN 18
  AND 40
</code></pre>
</div>
</div>
<p>Like in SQL, ranges are inclusive.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dates--times"><a class="header" href="#dates--times">Dates &amp; Times</a></h1>
<p>PRQL uses a pattern of prefacing strings with their type to represent dates.
This is less verbose than SQL's approach of <code>TIMESTAMP '2004-10-19 10:23:54'</code>
and more explicit than SQL's implicit option of just using a string <code>'2004-10-19 10:23:54'</code>.</p>
<blockquote>
<p>Currently PRQL passes strings straight through to the database, and so any
compatible format string will work, but we may refine this in the future to aid
in compatibility across databases. We'll always support the
<a href="https://en.wikipedia.org/wiki/ISO_8601">ISO8601</a> format.</p>
</blockquote>
<h2 id="dates"><a class="header" href="#dates">Dates</a></h2>
<p>Dates are represented by <code>@{yyyy-mm-dd}</code> — a <code>D</code> followed by the
date format.</p>
<div class="comparison">
<div>
<h4 id="prql-36"><a class="header" href="#prql-36">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive age_at_year_end = (@2022-12-31 - dob)
</code></pre>
</div>
<div>
<h4 id="sql-36"><a class="header" href="#sql-36">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  DATE '2022-12-31' - dob AS age_at_year_end
FROM
  employees
</code></pre>
</div>
</div>
<h2 id="times"><a class="header" href="#times">Times</a></h2>
<p>Times are represented by <code>@{HH:mm:ss.SSS±Z}</code> with any parts not supplied being
rounded to zero, including the timezone, which is represented by <code>+HH:mm</code>,
<code>-HH:mm</code> or <code>Z</code>. This is consistent with the ISO8601 time format.</p>
<div class="comparison">
<div>
<h4 id="prql-37"><a class="header" href="#prql-37">PRQL</a></h4>
<pre><code class="language-prql">from orders
derive should_have_shipped_today = (order_time &lt; @08:30)
</code></pre>
</div>
<div>
<h4 id="sql-37"><a class="header" href="#sql-37">SQL</a></h4>
<pre><code class="language-sql">SELECT
  orders.*,
  order_time &lt; TIME '08:30' AS should_have_shipped_today
FROM
  orders
</code></pre>
</div>
</div>
<h2 id="timestamps"><a class="header" href="#timestamps">Timestamps</a></h2>
<p>Timestamps are represented by <code>@{yyyy-mm-ddTHH:mm:ss.SSS±Z}</code> /
<code>@{date}T{time}</code>, with any time parts not supplied being rounded to zero,
including the timezone, which is represented by <code>+HH:mm</code>, <code>-HH:mm</code> or <code>Z</code>. This
is <code>@</code> followed by the ISO8601 time format, which uses <code>T</code> to separate date &amp;
time.</p>
<div class="comparison">
<div>
<h4 id="prql-38"><a class="header" href="#prql-38">PRQL</a></h4>
<pre><code class="language-prql">derive first_prql_commit = @2020-01-01T13:19:55-0800
</code></pre>
</div>
<div>
<h4 id="sql-38"><a class="header" href="#sql-38">SQL</a></h4>
<pre><code class="language-sql">SELECT
  TIMESTAMP '2020-01-01T13:19:55-0800' AS first_prql_commit
</code></pre>
</div>
</div>
<h2 id="intervals"><a class="header" href="#intervals">Intervals</a></h2>
<p>Intervals are represented by <code>{N}{periods}</code>, such as <code>2years</code> or <code>10minutes</code>,
without a space.</p>
<blockquote>
<p>These aren't the same as ISO8601, because we evaluated <code>P3Y6M4DT12H30M5S</code> to
be difficult to understand, but we could support a simplified form if there's
demand for it. We don't currently support compound expressions, for example
<code>2years10months</code>, but most DBs will allow <code>2years + 10months</code>. Please raise an
issue if this is inconvenient.</p>
</blockquote>
<div class="comparison">
<div>
<h4 id="prql-39"><a class="header" href="#prql-39">PRQL</a></h4>
<pre><code class="language-prql">from projects
derive first_check_in = start + 10days
</code></pre>
</div>
<div>
<h4 id="sql-39"><a class="header" href="#sql-39">SQL</a></h4>
<pre><code class="language-sql">SELECT
  projects.*,
  start + INTERVAL '10' DAY AS first_check_in
FROM
  projects
</code></pre>
</div>
</div>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<p>Here's a fuller list of examples:</p>
<ul>
<li><code>@20221231</code> is forbidden — it must contain full punctuation (<code>-</code> and <code>:</code>),</li>
<li><code>@2022-12-31</code> is a date</li>
<li><code>@2022-12</code> or <code>@2022</code> are forbidden — SQL can't express a month, only a date</li>
<li><code>@16:54:32.123456</code> is a time</li>
<li><code>@16:54:32</code>, <code>@16:54</code>, <code>@16</code> are all allowed, expressing <code>@16:54:32.000000</code>, <code>@16:54:00.000000</code>, <code>@16:00:00.000000</code> respectively</li>
<li><code>@2022-12-31T16:54:32.123456</code> is a timestamp without timezone</li>
<li><code>@2022-12-31T16:54:32.123456Z</code> is a timestamp in UTC</li>
<li><code>@2022-12-31T16:54+02</code> is timestamp in UTC+2</li>
<li><code>@2022-12-31T16:54+02:00</code> and <code>@2022-12-31T16:54+02</code> are datetimes in UTC+2</li>
<li><code>@16:54+02</code> is forbidden — time is always local, so it cannot have a timezone</li>
<li><code>@2022-12-31+02</code> is forbidden — date is always local, so it cannot have a timezone</li>
</ul>
<h2 id="todos"><a class="header" href="#todos">TODOs</a></h2>
<h3 id="datetimes"><a class="header" href="#datetimes">Datetimes</a></h3>
<p>Datetimes are supported by some databases (e.g. MySql, BigQuery) in addition to
timestamps. When we have type annotations, these will be represented by a
timestamp annotated as a datetime:</p>
<pre><code class="language-prql_no_test">derive pi_day = @2017-03-14T15:09:26.535898&lt;datetime&gt;
</code></pre>
<p>These are some examples we can then add:</p>
<ul>
<li><code>@2022-12-31T16:54&lt;datetime&gt;</code> is datetime without timezone</li>
<li><code>@2022-12-31&lt;datetime&gt;</code> is forbidden — datetime must specify time</li>
<li><code>@16:54&lt;datetime&gt;</code> is forbidden — datetime must specify date</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coalesce"><a class="header" href="#coalesce">Coalesce</a></h1>
<p>We can coalesce values with an <code>??</code> operator. Coalescing takes either the first
value or, if that value is null, the second value.</p>
<div class="comparison">
<div>
<h4 id="prql-40"><a class="header" href="#prql-40">PRQL</a></h4>
<pre><code class="language-prql">from orders
derive amount ?? 0
</code></pre>
</div>
<div>
<h4 id="sql-40"><a class="header" href="#sql-40">SQL</a></h4>
<pre><code class="language-sql">SELECT
  orders.*,
  COALESCE(amount, 0)
FROM
  orders
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<!-- Here we could explain how function parameters work, what is a list, S-strings, how to do aliases and so on. -->
<h3 id="lists"><a class="header" href="#lists">Lists</a></h3>
<ul>
<li>
<p>Most keywords that take a single argument can also take a list, so these are equivalent:</p>
<pre><code class="language-diff"> from employees
-select salary
+select [salary]
</code></pre>
</li>
<li>
<p>More examples in <a href="examples/list-equivalence.html"><strong>list-equivalence.md</strong></a>.</p>
</li>
</ul>
<h3 id="pipelines-1"><a class="header" href="#pipelines-1">Pipelines</a></h3>
<ul>
<li>A line-break generally creates a pipelined transformation. For example:</li>
</ul>
<div class="comparison">
<div>
<h4 id="prql-41"><a class="header" href="#prql-41">PRQL</a></h4>
<pre><code class="language-prql">from tbl
select [
  col1,
  col2,
]
filter col1 == col2
</code></pre>
</div>
<div>
<h4 id="sql-41"><a class="header" href="#sql-41">SQL</a></h4>
<pre><code class="language-sql">SELECT
  col1,
  col2
FROM
  tbl
WHERE
  col1 = col2
</code></pre>
</div>
</div>
<p>...is equivalent to:</p>
<div class="comparison">
<div>
<h4 id="prql-42"><a class="header" href="#prql-42">PRQL</a></h4>
<pre><code class="language-prql">from tbl | select [col1, col2] | filter col1 == col2
</code></pre>
</div>
<div>
<h4 id="sql-42"><a class="header" href="#sql-42">SQL</a></h4>
<pre><code class="language-sql">SELECT
  col1,
  col2
FROM
  tbl
WHERE
  col1 = col2
</code></pre>
</div>
</div>
<ul>
<li>A line-break doesn't created a pipeline in a few cases:
<ul>
<li>Within a list (e.g. the <code>select</code> example above).</li>
<li>When the following line is a new statement, by starting with a keyword such
as <code>func</code>.</li>
</ul>
</li>
</ul>
<h3 id="ctes"><a class="header" href="#ctes">CTEs</a></h3>
<ul>
<li>See <a href="examples/cte.html">CTE Example</a>.</li>
<li>This is no longer point-free, but that's a feature rather than a requirement.
The alternative is subqueries, which are fine at small scale, but become
difficult to digest as complexity increases.</li>
</ul>
<h3 id="punctuation-summary"><a class="header" href="#punctuation-summary">Punctuation summary</a></h3>
<p>A summary of how PRQL uses punctuation</p>
<p>| Syntax   | Usage                   | Example                                                                      |
| -------- | ----------------------- | ---------------------------------------------------------------------------- |
| <code>:</code>      | Named args &amp; Parameters | <code>interp lower:0 1600 sat_score</code>                                              |
| <code>=</code>      | Assigns &amp; Aliases       | <code>derive temp_c = (temp_f | celsius_of_fahrenheit)</code> <br> <code>from e = employees</code> |
| <code>==</code>     | Equality comparison     | <code>join s=salaries [s.employee_id == employees.id]</code>                            |
| <code>-&gt;</code>     | Function definitions    | <code>func add a b -&gt; a + b</code>                                                      |
| <code>&lt;type&gt;</code> | Annotations             | <code>@2021-01-01&lt;datetime&gt;</code>                                                      |
| <code>+</code>/<code>-</code>  | Sort order              | <code>sort [-amount, +date]</code>                                                      |</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-handling"><a class="header" href="#null-handling">Null handling</a></h1>
<p>SQL has an unconventional way of handling <code>NULL</code> values, since it treats them as unknown values. In consequence:</p>
<ul>
<li><code>NULL</code> is not a value indicating a missing entry, but a placeholder for anything possible,</li>
<li><code>NULL = NULL</code> evaluates to <code>NULL</code>, since one cannot know if one unknown is equal to another unknown,</li>
<li><code>NULL &lt;&gt; NULL</code> evaluates to <code>NULL</code>, using same logic,</li>
<li>to check if a value is <code>NULL</code>, SQL introduces <code>IS NULL</code> and <code>IS NOT NULL</code> operators,</li>
<li><code>DISTINCT column</code> may return multiple <code>NULL</code> values.</li>
</ul>
<p>For more information, read <a href="https://www.postgresql.org/docs/current/functions-comparison.html">Postgres documentation</a>.</p>
<p>PRQL, on the other hand, treats <code>null</code> as a value, which means that:</p>
<ul>
<li><code>null == null</code> evaluates to <code>true</code>,</li>
<li><code>null != null</code> evaluates to <code>false</code>,</li>
<li>distinct column cannot contain multiple <code>null</code> values.</li>
</ul>
<p>This approach was discussed in <a href="https://github.com/prql/prql/issues/99">issue #99</a>.</p>
<blockquote>
<p>Note, currently <code>DISTINCT</code> is not yet implemented, see <a href="https://github.com/prql/prql/issues/292">#292</a></p>
</blockquote>
<div class="comparison">
<div>
<h4 id="prql-43"><a class="header" href="#prql-43">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter first_name == null
filter null != last_name
</code></pre>
</div>
<div>
<h4 id="sql-43"><a class="header" href="#sql-43">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
WHERE
  first_name IS NULL
  AND last_name IS NOT NULL
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<!--
TODOs:
- Examples are a bit artificial — the interp is just "divide by 100" in one case!  -->
<p>Functions are a fundamental abstraction in PRQL — they allow us to run code in
many places that we've written once. This reduces the number of errors in our
code, makes our code more readable, and simplifies making changes.</p>
<p>Functions have two types of parameters:</p>
<ol>
<li>Positional parameters, which require an argument.</li>
<li>Named parameters, which optionally take an argument, otherwise using their
default value.</li>
</ol>
<p>So this function is named <code>celsius_of_fahrenheit</code> and has one parameter <code>temp</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-44"><a class="header" href="#prql-44">PRQL</a></h4>
<pre><code class="language-prql">func celsius_of_fahrenheit temp -&gt;  (temp - 32) * 3

from cities
derive temp_c = (celsius_of_fahrenheit temp_f)
</code></pre>
</div>
<div>
<h4 id="sql-44"><a class="header" href="#sql-44">SQL</a></h4>
<pre><code class="language-sql">SELECT
  cities.*,
  temp_f - 32 * 3 AS temp_c
FROM
  cities
</code></pre>
</div>
</div>
<p>This function is named <code>interp</code>, and has two positional parameters named
<code>higher</code> and <code>x</code>, and one named parameter named <code>lower</code> which takes a default
argument of <code>0</code>. It calculates the proportion of the distance that <code>x</code> is
between <code>lower</code> and <code>higher</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-45"><a class="header" href="#prql-45">PRQL</a></h4>
<pre><code class="language-prql">func interp lower:0 higher x -&gt;  (x - lower) / (higher - lower)

from students
derive [
  sat_proportion_1 = (interp 1600 sat_score),
  sat_proportion_2 = (interp lower:0 1600 sat_score),
]
</code></pre>
</div>
<div>
<h4 id="sql-45"><a class="header" href="#sql-45">SQL</a></h4>
<pre><code class="language-sql">SELECT
  students.*,
  sat_score - 0 / 1600 - 0 AS sat_proportion_1,
  sat_score - 0 / 1600 - 0 AS sat_proportion_2
FROM
  students
</code></pre>
</div>
</div>
<h2 id="piping"><a class="header" href="#piping">Piping</a></h2>
<p>Consistent with the principles of PRQL, it's possible to pipe values into
functions, which makes composing many functions more readable. When piping a
value into a function, the value is passed as an argument to the final
positional parameter of the function. Here's the same result as the examples
above with an alternative construction:</p>
<div class="comparison">
<div>
<h4 id="prql-46"><a class="header" href="#prql-46">PRQL</a></h4>
<pre><code class="language-prql">func interp lower:0 higher x -&gt;  (x - lower) / (higher - lower)

from students
derive [
  sat_proportion_1 = (sat_score | interp 1600),
  sat_proportion_2 = (sat_score | interp lower:0 1600),
]
</code></pre>
</div>
<div>
<h4 id="sql-46"><a class="header" href="#sql-46">SQL</a></h4>
<pre><code class="language-sql">SELECT
  students.*,
  sat_score - 0 / 1600 - 0 AS sat_proportion_1,
  sat_score - 0 / 1600 - 0 AS sat_proportion_2
FROM
  students
</code></pre>
</div>
</div>
<p>and</p>
<div class="comparison">
<div>
<h4 id="prql-47"><a class="header" href="#prql-47">PRQL</a></h4>
<pre><code class="language-prql">func celsius_of_fahrenheit temp -&gt;  (temp - 32) * 3

from cities
derive temp_c = (temp_f | celsius_of_fahrenheit)
</code></pre>
</div>
<div>
<h4 id="sql-47"><a class="header" href="#sql-47">SQL</a></h4>
<pre><code class="language-sql">SELECT
  cities.*,
  temp_f - 32 * 3 AS temp_c
FROM
  cities
</code></pre>
</div>
</div>
<p>We can combine a chain of functions, which makes logic more readable:</p>
<div class="comparison">
<div>
<h4 id="prql-48"><a class="header" href="#prql-48">PRQL</a></h4>
<pre><code class="language-prql">func celsius_of_fahrenheit temp -&gt;  (temp - 32) * 3
func interp lower:0 higher x -&gt;  (x - lower) / (higher - lower)

from kettles
derive boiling_proportion = (temp_c | celsius_of_fahrenheit | interp 100)
</code></pre>
</div>
<div>
<h4 id="sql-48"><a class="header" href="#sql-48">SQL</a></h4>
<pre><code class="language-sql">SELECT
  kettles.*,
  temp_c - 32 * 3 - 0 / 100 - 0 AS boiling_proportion
FROM
  kettles
</code></pre>
</div>
</div>
<h2 id="todos-1"><a class="header" href="#todos-1">TODOs</a></h2>
<h3 id="late-binding"><a class="header" href="#late-binding">Late binding</a></h3>
<p>Currently, functions require a binding to variables in scope; they can't
late-bind to column names; so for example:</p>
<pre><code class="language-prql_no_test">func return price -&gt;  (price - dividend) / price_yesterday
</code></pre>
<p>...isn't yet a valid function, and instead would needs to be:</p>
<pre><code class="language-prql_no_test">func return price dividend price_yesterday -&gt;  (price - dividend) / (price_yesterday)
</code></pre>
<p>(which makes functions in this case not useful)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdlib"><a class="header" href="#stdlib">Stdlib</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="live-editor"><a class="header" href="#live-editor">Live Editor</a></h1>
<!-- The `container-container` properties already exist on `editor-container`, but we
need to re-specify them since there's another layer (maybe avoidable?). -->
<!-- We specify all the hierarchy, from html down, to have height=100%, in order to
get the editors to be full height, and add some reductions in `px` to two
elements, to prevent scroll bars / awkward scrolling when the line breaks run
on. We previously had a different approach, which aligned the content such that
we didn't need scrollbars, but it didn't work well on Chrome. -->
<!-- TODO:
- Should we have a max-width to limit the width for very wide browsers?
- If so, can we get the editors to center?
 -->
<style>
    html, body, .page-wrapper, .page , .container-container {
        height: 100%;
        box-sizing: border-box;
    }
     main {
        height: calc(100% - 150px);
        box-sizing: border-box;
    }
    .content {
        height: calc(100% - 70px);
        box-sizing: border-box;
    }
    main {
        /*Override the main CSS so that the Editors can be wide*/
        max-width: none !important;
    }
    .container-container {
        width: 100%;
    }
    .nav-chapters, .nav-wrapper {
        visibility: hidden;
    }
</style>
<embed class="container-container" type="text/html" src="./dist/index.html">
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-9"><a class="header" href="#examples-9">Examples</a></h1>
<p>These examples are rewritten from other languages such as SQL. They try to express real-world problems in PRQL, covering most of the language features. We are looking for different use-cases of data transformation, be it database queries, semnatic bussiness modeling or data cleaning.</p>
<p>If you want to help, translate some of your queries to PRQL and <a href="https://github.com/prql/prql/pulls">open a PR</a> to add them here!</p>
<!-- TODO: toc -->
<div style="break-before: page; page-break-before: always;"></div><div class="comparison">
<div>
<h4 id="prql-49"><a class="header" href="#prql-49">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter country == &quot;USA&quot;                       # Each line transforms the previous result.
derive [                                     # This adds columns / variables.
  gross_salary = salary + payroll_tax,
  gross_cost = gross_salary + benefits_cost  # Variables can use other variables.
]
filter gross_cost &gt; 0
group [title, country] (                     # For each group use a nested pipeline
  aggregate [                                # Aggregate each group to a single row
    average salary,
    average gross_salary,
    sum salary,
    sum gross_salary,
    average gross_cost,
    sum_gross_cost = sum gross_cost,
    ct = count,
  ]
)
sort sum_gross_cost
filter ct &gt; 200
take 20
</code></pre>
</div>
<div>
<h4 id="sql-49"><a class="header" href="#sql-49">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  AVG(salary + payroll_tax),
  SUM(salary),
  SUM(salary + payroll_tax),
  AVG(salary + payroll_tax + benefits_cost),
  SUM(salary + payroll_tax + benefits_cost) AS sum_gross_cost,
  COUNT(*) AS ct
FROM
  employees
WHERE
  country = 'USA'
  AND salary + payroll_tax + benefits_cost &gt; 0
GROUP BY
  title,
  country
HAVING
  COUNT(*) &gt; 200
ORDER BY
  sum_gross_cost
LIMIT
  20
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-50"><a class="header" href="#prql-50">PRQL</a></h4>
<pre><code class="language-prql">from employees
group [emp_no] (
  aggregate [
    emp_salary = average salary     # average salary resolves to &quot;AVG(salary)&quot; (from stdlib)
  ]
)
join titles [emp_no]
group [title] (
  aggregate [
    avg_salary = average emp_salary
  ]
)
select salary_k = avg_salary / 1000 # avg_salary should resolve to &quot;AVG(emp_salary)&quot;
take 10                             # induces new SELECT
derive salary = salary_k * 1000     # salary_k should not resolve to &quot;avg_salary / 1000&quot;
</code></pre>
</div>
<div>
<h4 id="sql-50"><a class="header" href="#sql-50">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    emp_no,
    AVG(salary) AS emp_salary
  FROM
    employees
  GROUP BY
    emp_no
)
SELECT
  AVG(table_0.emp_salary) / 1000 AS salary_k,
  AVG(table_0.emp_salary) / 1000 * 1000 AS salary
FROM
  table_0
  JOIN titles USING(emp_no)
GROUP BY
  titles.title
LIMIT
  10
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="single-item-is-coerced-into-a-list"><a class="header" href="#single-item-is-coerced-into-a-list">Single item is coerced into a list</a></h2>
<div class="comparison">
<div>
<h4 id="prql-51"><a class="header" href="#prql-51">PRQL</a></h4>
<pre><code class="language-prql">from employees
select salary
</code></pre>
</div>
<div>
<h4 id="sql-51"><a class="header" href="#sql-51">SQL</a></h4>
<pre><code class="language-sql">SELECT
  salary
FROM
  employees
</code></pre>
</div>
</div>
<p>Same as above but with <code>salary</code> in a list:</p>
<div class="comparison">
<div>
<h4 id="prql-52"><a class="header" href="#prql-52">PRQL</a></h4>
<pre><code class="language-prql">from employees
select [salary]
</code></pre>
</div>
<div>
<h4 id="sql-52"><a class="header" href="#sql-52">SQL</a></h4>
<pre><code class="language-sql">SELECT
  salary
FROM
  employees
</code></pre>
</div>
</div>
<h2 id="multiple-items"><a class="header" href="#multiple-items">Multiple items</a></h2>
<div class="comparison">
<div>
<h4 id="prql-53"><a class="header" href="#prql-53">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive [
  gross_salary = salary + payroll_tax,
  gross_cost = gross_salary + benefits_cost
]
</code></pre>
</div>
<div>
<h4 id="sql-53"><a class="header" href="#sql-53">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary,
  salary + payroll_tax + benefits_cost AS gross_cost
FROM
  employees
</code></pre>
</div>
</div>
<p>Same as above but split into two lines:</p>
<div class="comparison">
<div>
<h4 id="prql-54"><a class="header" href="#prql-54">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive gross_salary = salary + payroll_tax
derive gross_cost = gross_salary + benefits_cost
</code></pre>
</div>
<div>
<h4 id="sql-54"><a class="header" href="#sql-54">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary,
  salary + payroll_tax + benefits_cost AS gross_cost
FROM
  employees
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><p>This mostly works, apart from window clauses, and the version &amp; db args on the
first line.</p>
<pre><code class="language-prql_no_test">prql version:0.1 db:snowflake                         # Version number &amp; database name.

func lag_day x -&gt;  (
  window x
  by sec_id
  sort date
  lag 1
)
func ret x -&gt;  x / (x | lag_day) - 1 + dividend_return
func excess x -&gt;  (x - interest_rate) / 252
func if_valid x -&gt;  is_valid_price ? x : null

from prices
derive [
  return_total =      prices_adj   | ret | if_valid  # `|` can be used rather than newlines.
  return_usd =        prices_usd   | ret | if_valid
  return_excess =     return_total | excess
  return_usd_excess = return_usd   | excess
]
select [
  date,
  sec_id,
  return_total,
  return_usd,
  return_excess,
  return_usd_excess,
]
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>The SQL can be a bit better, by pulling the window clause out.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="comparison">
<div>
<h4 id="prql-55"><a class="header" href="#prql-55">PRQL</a></h4>
<pre><code class="language-prql">table newest_employees = (
  from employees
  sort tenure
  take 50
)

table average_salaries = (
  from salaries
  group country (
    aggregate average_country_salary = (average salary)
  )
)

from newest_employees
join average_salaries [country]
select [name, salary, average_country_salary]
</code></pre>
</div>
<div>
<h4 id="sql-55"><a class="header" href="#sql-55">SQL</a></h4>
<pre><code class="language-sql">WITH newest_employees AS (
  SELECT
    employees.*
  FROM
    employees
  ORDER BY
    tenure
  LIMIT
    50
), average_salaries AS (
  SELECT
    country,
    AVG(salary) AS average_country_salary
  FROM
    salaries
  GROUP BY
    country
)
SELECT
  name,
  average_salaries.salary,
  average_salaries.average_country_salary
FROM
  newest_employees
  JOIN average_salaries USING(country)
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div class="comparison">
<div>
<h4 id="prql-56"><a class="header" href="#prql-56">PRQL</a></h4>
<pre><code class="language-prql">from mytable
filter id == $1
</code></pre>
</div>
<div>
<h4 id="sql-56"><a class="header" href="#sql-56">SQL</a></h4>
<pre><code class="language-sql">SELECT
  mytable.*
FROM
  mytable
WHERE
  id = $1
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="employees"><a class="header" href="#employees">Employees</a></h1>
<p>These are homework tasks on <a href="https://github.com/vrajmohan/pgsql-sample-data.git">employees database</a>.</p>
<p>Clone and init the database (requires a local PostgreSQL instance):</p>
<pre><code>$ psql -U postgres -c 'CREATE DATABASE employees;'
$ git clone https://github.com/vrajmohan/pgsql-sample-data.git
$ psql -U postgres -d employees -f pgsql-sample-data/employee/employees.dump
</code></pre>
<p>Execute a PRQL query:</p>
<pre><code>$ cargo run compile examples/employees/average-title-salary.prql | psql -U postgres -d employees
</code></pre>
<h2 id="task-1"><a class="header" href="#task-1">Task 1</a></h2>
<blockquote>
<p>rank the employee titles according to the average salary for each department.</p>
</blockquote>
<p>My solution:</p>
<ul>
<li>for each employee, find their average salary,</li>
<li>join employees with their departments and titles (duplicating employees for each of their titles and departments)</li>
<li>group by department and title, aggregating average salary</li>
<li>join with department to get department name</li>
</ul>
<div class="comparison">
<div>
<h4 id="prql-57"><a class="header" href="#prql-57">PRQL</a></h4>
<pre><code class="language-prql">from salaries
group [emp_no] (
  aggregate [emp_salary = average salary]
)
join t=titles [emp_no]
join dept_emp side:left [emp_no]
group [dept_emp.dept_no, t.title] (
  aggregate [avg_salary = average emp_salary]
)
join departments [dept_no]
select [dept_name, title, avg_salary]
</code></pre>
</div>
<div>
<h4 id="sql-57"><a class="header" href="#sql-57">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    emp_no,
    AVG(salary) AS emp_salary
  FROM
    salaries
  GROUP BY
    emp_no
),
table_1 AS (
  SELECT
    dept_emp.dept_no,
    t.title,
    AVG(table_0.emp_salary) AS avg_salary
  FROM
    table_0
    JOIN titles AS t USING(emp_no)
    LEFT JOIN dept_emp USING(emp_no)
  GROUP BY
    dept_emp.dept_no,
    t.title
)
SELECT
  departments.dept_name,
  table_1.title,
  table_1.avg_salary
FROM
  table_1
  JOIN departments USING(dept_no)
</code></pre>
</div>
</div>
<h2 id="task-2"><a class="header" href="#task-2">Task 2</a></h2>
<blockquote>
<p>The company active pursues gender equality.</p>
<p>Prepare an analysis based on salaries and gender distribution by departments.</p>
</blockquote>
<div class="comparison">
<div>
<h4 id="prql-58"><a class="header" href="#prql-58">PRQL</a></h4>
<pre><code class="language-prql">from employees
join salaries [emp_no]
group [emp_no, gender] (
  aggregate [
    emp_salary = average salary
  ]
)
join de=dept_emp [emp_no] side:left
group [de.dept_no, gender] (
  aggregate [
    salary_avg = average emp_salary,
    salary_sd = stddev emp_salary,
  ]
)
join departments [dept_no]
select [dept_name, gender, salary_avg, salary_sd]
</code></pre>
</div>
<div>
<h4 id="sql-58"><a class="header" href="#sql-58">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    emp_no,
    gender,
    AVG(salary) AS emp_salary
  FROM
    employees
    JOIN salaries USING(emp_no)
  GROUP BY
    emp_no,
    gender
),
table_1 AS (
  SELECT
    de.dept_no,
    de.gender,
    AVG(table_0.emp_salary) AS salary_avg,
    STDDEV(table_0.emp_salary) AS salary_sd
  FROM
    table_0
    LEFT JOIN dept_emp AS de USING(emp_no)
  GROUP BY
    de.dept_no,
    de.gender
)
SELECT
  departments.dept_name,
  table_1.gender,
  table_1.salary_avg,
  table_1.salary_sd
FROM
  table_1
  JOIN departments USING(dept_no)
</code></pre>
</div>
</div>
<h2 id="task-3"><a class="header" href="#task-3">Task 3</a></h2>
<blockquote>
<p>The company active pursues gender equality.</p>
<p>Prepare an analysis based on salaries and gender distribution by managers.</p>
</blockquote>
<div class="comparison">
<div>
<h4 id="prql-59"><a class="header" href="#prql-59">PRQL</a></h4>
<pre><code class="language-prql">from employees
join salaries [emp_no]
group [emp_no, gender] (
  aggregate [
    emp_salary = average salary
  ]
)
join de=dept_emp [emp_no]
join dm=dept_manager [
  (dm.dept_no == de.dept_no) and s&quot;(de.from_date, de.to_date) OVERLAPS (dm.from_date, dm.to_date)&quot;
]
group [dm.emp_no, gender] (
  aggregate [
    salary_avg = average emp_salary,
    salary_sd = stddev emp_salary
  ]
)
derive mng_no = dm.emp_no
join managers=employees [emp_no]
derive mng_name = s&quot;managers.first_name || ' ' || managers.last_name&quot;
select [mng_name, managers.gender, salary_avg, salary_sd]
</code></pre>
</div>
<div>
<h4 id="sql-59"><a class="header" href="#sql-59">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    emp_no,
    gender,
    AVG(salary) AS emp_salary
  FROM
    employees
    JOIN salaries USING(emp_no)
  GROUP BY
    emp_no,
    gender
),
table_1 AS (
  SELECT
    dm.emp_no,
    gender,
    AVG(table_0.emp_salary) AS salary_avg,
    STDDEV(table_0.emp_salary) AS salary_sd,
    dm.emp_no AS mng_no
  FROM
    table_0
    JOIN dept_emp AS de USING(emp_no)
    JOIN dept_manager AS dm ON dm.dept_no = de.dept_no
    AND (de.from_date, de.to_date) OVERLAPS (dm.from_date, dm.to_date)
  GROUP BY
    dm.emp_no,
    gender
)
SELECT
  managers.first_name || ' ' || managers.last_name AS mng_name,
  managers.gender,
  table_1.salary_avg,
  table_1.salary_sd
FROM
  table_1
  JOIN employees AS managers USING(emp_no)
</code></pre>
</div>
</div>
<h2 id="task-4"><a class="header" href="#task-4">Task 4</a></h2>
<blockquote>
<p>Find distributions of titles, salaries and genders over different departments.</p>
</blockquote>
<div class="comparison">
<div>
<h4 id="prql-60"><a class="header" href="#prql-60">PRQL</a></h4>
<pre><code class="language-prql">from de=dept_emp
join s=salaries side:left [
  (s.emp_no == de.emp_no),
  s&quot;({s.from_date}, {s.to_date}) OVERLAPS ({de.from_date}, {de.to_date})&quot;
]
group [de.emp_no, de.dept_no] (
  aggregate salary = (average s.salary)
)
join employees [emp_no]
join titles [emp_no]
select [dept_no, salary, employees.gender, titles.title]
</code></pre>
</div>
<div>
<h4 id="sql-60"><a class="header" href="#sql-60">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    de.emp_no,
    de.dept_no,
    AVG(s.salary) AS salary
  FROM
    dept_emp AS de
    LEFT JOIN salaries AS s ON s.emp_no = de.emp_no (s.from_date, s.to_date) OVERLAPS (de.from_date, de.to_date)
  GROUP BY
    de.emp_no,
    de.dept_no
)
SELECT
  table_0.dept_no,
  table_0.salary,
  employees.gender,
  titles.title
FROM
  table_0
  JOIN employees USING(emp_no)
  JOIN titles USING(emp_no)
</code></pre>
</div>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="highlight-prql.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
